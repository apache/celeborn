/*
 * Copyright 2021 The Flink Remote Shuffle Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.alibaba.flink.shuffle.common.utils;

import javax.annotation.Nullable;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Optional;
import java.util.function.Predicate;

/** Utility for manipulating exceptions. */
public class ExceptionUtils {

    /**
     * Checks whether the given exception indicates a situation that may leave the JVM in a
     * corrupted state, meaning a state where continued normal operation can only be guaranteed via
     * clean process restart.
     */
    public static boolean isJvmFatalError(Throwable t) {
        return (t instanceof InternalError)
                || (t instanceof UnknownError)
                || (t instanceof ThreadDeath);
    }

    /**
     * Checks whether the given exception indicates a situation that may leave the JVM in a
     * corrupted state, or an out-of-memory error.
     */
    public static boolean isJvmFatalOrOutOfMemoryError(Throwable t) {
        return isJvmFatalError(t) || t instanceof OutOfMemoryError;
    }

    /**
     * Checks whether the given exception indicates a JVM metaspace out-of-memory error.
     *
     * @param t The exception to check.
     * @return True, if the exception is the metaspace {@link OutOfMemoryError}, false otherwise.
     */
    public static boolean isMetaspaceOutOfMemoryError(@Nullable Throwable t) {
        return isOutOfMemoryErrorWithMessageStartingWith(t, "Metaspace");
    }

    /** Checks whether the given exception indicates a JVM direct out-of-memory error. */
    public static boolean isDirectOutOfMemoryError(@Nullable Throwable t) {
        return isOutOfMemoryErrorWithMessageStartingWith(t, "Direct buffer memory");
    }

    public static boolean isHeapSpaceOutOfMemoryError(@Nullable Throwable t) {
        return isOutOfMemoryErrorWithMessageStartingWith(t, "Java heap space");
    }

    private static boolean isOutOfMemoryErrorWithMessageStartingWith(
            @Nullable Throwable t, String prefix) {
        // the exact matching of the class is checked to avoid matching any custom subclasses of
        // OutOfMemoryError as we are interested in the original exceptions, generated by JVM.
        return isOutOfMemoryError(t) && t.getMessage() != null && t.getMessage().startsWith(prefix);
    }

    private static boolean isOutOfMemoryError(@Nullable Throwable t) {
        return t != null && t.getClass() == OutOfMemoryError.class;
    }

    /** Rethrows the target {@link Throwable} as {@link Error} or {@link RuntimeException}. */
    public static void rethrowAsRuntimeException(Throwable t) {
        if (t instanceof Error) {
            throw (Error) t;
        } else if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new RuntimeException(t);
        }
    }

    /** Rethrows the target {@link Throwable} as {@link Error} or {@link Exception}. */
    public static void rethrowException(Throwable throwable) throws Exception {
        if (throwable instanceof Error) {
            throw (Error) throwable;
        } else {
            throw (Exception) throwable;
        }
    }

    /**
     * Unpacks an specified exception and returns its cause. Otherwise the given {@link Throwable}
     * is returned.
     */
    public static Throwable stripException(
            Throwable throwableToStrip, Class<? extends Throwable> typeToStrip) {
        while (typeToStrip.isAssignableFrom(throwableToStrip.getClass())
                && throwableToStrip.getCause() != null) {
            throwableToStrip = throwableToStrip.getCause();
        }
        return throwableToStrip;
    }

    /** Checks whether a throwable chain contains a specific type of exception and returns it. */
    public static <T extends Throwable> Optional<T> findThrowable(
            Throwable throwable, Class<T> searchType) {
        if (throwable == null || searchType == null) {
            return Optional.empty();
        }

        Throwable cause = throwable;
        while (cause != null) {
            if (searchType.isAssignableFrom(cause.getClass())) {
                return Optional.of(searchType.cast(cause));
            } else {
                cause = cause.getCause();
            }
        }
        return Optional.empty();
    }

    /**
     * Checks whether a throwable chain contains an exception matching a predicate and returns it.
     *
     * <p>This method is copied from Apache Flink (org.apache.flink.util.ExceptionUtils).
     *
     * @param throwable the throwable chain to check.
     * @param predicate the predicate of the exception to search for in the chain.
     * @return Optional throwable of the requested type if available, otherwise empty.
     */
    public static Optional<Throwable> findThrowable(
            Throwable throwable, Predicate<Throwable> predicate) {
        if (throwable == null || predicate == null) {
            return Optional.empty();
        }

        Throwable t = throwable;
        while (t != null) {
            if (predicate.test(t)) {
                return Optional.of(t);
            } else {
                t = t.getCause();
            }
        }

        return Optional.empty();
    }

    public static String summaryErrorMessageStack(Throwable t) {
        StringBuilder sb = new StringBuilder();
        do {
            if (sb.length() != 0) {
                sb.append(" -> ");
            }
            sb.append("[")
                    .append(t.getClass().getName())
                    .append(": ")
                    .append(t.getMessage())
                    .append("]");
        } while ((t = t.getCause()) != null);
        return sb.toString();
    }

    /**
     * Makes a string representation of the exception's stack trace, or "(null)", if the exception
     * is null.
     */
    public static String stringifyException(Throwable exception) {
        if (exception == null) {
            return "(null)";
        }

        try {
            StringWriter stm = new StringWriter();
            PrintWriter wrt = new PrintWriter(stm);
            exception.printStackTrace(wrt);
            wrt.close();
            return stm.toString();
        } catch (Throwable throwable) {
            return exception.getClass().getName() + " (error while printing stack trace)";
        }
    }
}
